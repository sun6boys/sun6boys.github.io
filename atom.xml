<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Charon的小窝</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://charonchu.club/"/>
  <updated>2017-12-30T16:51:09.016Z</updated>
  <id>http://charonchu.club/</id>
  
  <author>
    <name>Charon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP协议小叙</title>
    <link href="http://charonchu.club/2017/12/31/TCP%E5%8D%8F%E8%AE%AE%E5%B0%8F%E5%8F%99/"/>
    <id>http://charonchu.club/2017/12/31/TCP协议小叙/</id>
    <published>2017-12-30T16:50:34.000Z</published>
    <updated>2017-12-30T16:51:09.016Z</updated>
    
    <content type="html"><![CDATA[<p>目前大多数app和服务器通信的时候才有的HTTP应用层协议，而HTTP又是TCP协议实现的，所以TCP协议的重要性不言而喻。TCP是一个传输层协议位于IP协议网络层之上。从很多书籍和资料上解释TCP是可靠的传输层协议。结合下面的内容就会得到分析为什么TCP协议是可靠的传输层协议。</p><h3 id="1-TCP-Header"><a href="#1-TCP-Header" class="headerlink" title="1.TCP Header"></a>1.TCP Header</h3><p>一个TCP包由header和payload组成，payload就是待传输的数据，header信息中包含了一些对payload的描述以及一些TCP传输控制策略等，如下图。</p><p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/lpnueg4/EntryImages/20091120/TCP+bit%E5%89%AF%E6%9C%AC.png" alt="icon"></p><ul><li><strong>Source Port</strong> <code>源端口号</code>标识发送主机发起传送的应用程序。端口号在IP总结一文中作了解释，所以当时为什么说端口号应属于传输层当中的内容。</li><li><strong>Destonation Port</strong> <code>目标端口号</code> 标识目标主机接收数据的应用程序。</li><li><strong>Sequence Number</strong> <code>序列号</code> 标识该TCP包中payload第一个字节的编号，发送方必填。</li><li><strong>Acknowledgment Number</strong> <code>确认号</code> 接收方每次接收到发送方传来的数据包需要告诉发送方我已经收到了该数据（TCP可靠性体现之一，当然也并不是每个包都会被回复，下文会具体叙述），<code>确认号</code> = <code>序号和</code> + payload字节数 + 1,代表期待对方下次可以从序号号为<strong>Acknowledgment Number</strong>开始发送。意思是（Acknowledgment Number - 1）和它之前的数据已经成功收到，不需要重发那些。</li><li><strong>Data Offset</strong> 4位，也就是头部长度，指出TCP负载（数据）的开始位置。以4字节为单位，如”0101”表示20字节位置的数据为负载开始，也就是头部长度为20字节。</li><li><p><strong>Control Falg</strong> <code>控制标记</code></p><ul><li><strong>URG</strong> 如果数值为1，表示这是一个携有紧急资料的封包</li><li><strong>ACK</strong> 如果数值为1，表示该包需要回复，正常情况都是1</li><li><strong>PSH</strong> 如果为1，通知接收方立即将数据包交给应用层，而不是等缓冲区满了再交付应用层</li><li><strong>SYN</strong> 如果为1 表示双方进行同步沟通</li><li><strong>FIN</strong> 如果未1 表示任意一方已经没有数据传输了，请求终止链接。</li></ul></li><li><p><strong>Window</strong> <code>窗口</code> 接收窗口大小。用来进行流量控制，单位字节数。发送方有发送窗口，接收方有接收窗口，窗口大小代表着处理数据的能力，如果接收方发送数据的速度大于接收方处理数据的能力，那多余的数据将会丢失。</p></li><li><strong>Checksum</strong> <code>校验位</code>16位，对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。当资料要传送出去的时候发送端会计算好封包资料大小然後得出这个检验值封包一起发送当接收端收到封包之後会再对资料大小进行计算看看是否和检验值一致如果结果不相称则被视为残缺封包会要求对方重发该个封包。</li><li>…</li></ul><h3 id="2-TCP分段"><a href="#2-TCP分段" class="headerlink" title="2. TCP分段"></a>2. TCP分段</h3><p>在<a href="https://github.com/sun6boys/Documents/blob/master/1.IP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">IP协议总结</a>中说到当数据包在经过网络层，如果数据包体积超过了MTU，会把数据包分片传输。IP包在复杂的网络传输当中，可能会发生各种意外情况，比如丢包等等。TCP既然被称为可靠的协议，显然要改变这个状况。</p><p>可靠性最大的体现在发送方给接收方的数据都能够接收到，如果某一个数据没有接收到，发送方需要重新给接收方再次发送。</p><p>所以TCP的header当中<strong>Sequence Number</strong>和<strong>Acknowledgment Number</strong>就是为了实现确认和重发功能，具体见上文。</p><p><strong>举例：</strong></p><ul><li><p>发送方 需要发送1、2、3、4…、99、100共100个数字给接收方，TCP把这100个数字打包，在TCP header中记录<strong>Sequence Number</strong>，IP层接收到TCP层过来的数据，加上IP header超过了MTU大小，于是把数据包分片，第一片数据是1-50个数字，第二片是51 -100个数字，分别发送出去。</p></li><li><p>接收方收到第一个包，经过层层拆包，至TCP层，接收方根据<strong>Sequence Number</strong>回复一个<strong>Acknowledgment Number</strong>给接收方，接收方收到回复包，看到<strong>Acknowledgment Number</strong>会认为接收方已经收到完整数据了。</p></li><li><p>在这个过程当中发送方认为接收方已经收到了数据，而接收方可能只接收到了1-50的数据，51-100并没有接收到。</p></li></ul><p>TCP为了避免这样的情况发生，他需要接管数据分段，避免被IP分片。</p><p>IP数据不会发生分片前提是： IP header + IP 实际传输的数据 &lt;= MTU。</p><p>因为TCP也会封装header，他要保证单个数据包至IP层不会被分片，公式是：TCP header + TCP payload + IP header &lt;= MTU.</p><p>暂且认为TCP header 和 IP header大小固定不变，在<a href="https://github.com/sun6boys/Documents/blob/master/1.IP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">IP协议总结</a>提到过MTU，MTU大小会因为数据传输过程中物理介质不一样，以及运营商流量计费采用了比如PPPoE等协议，会给数据包二次封装等原因造成了MTU的大小不一致。</p><p>既然如此，发送方和接收方就要在正式数据传输前，约定好TCP payload的最大体积以保证不会让IP分片，这就是<strong>MSS</strong></p><p>由此可得出IP分片和TCP分段的区别：</p><ul><li>IP分片产生的原因是网络层的MTU；TCP分段产生原因是MSS，产生MSS原因其实也是MTU；</li><li>IP分片由网络层完成，也在网络层进行重组；TCP分段是在传输层完成，并在传输层进行重组；</li></ul><p>故采用TCP协议进行数据传输，是不会造成IP分片的。若数据过大，只会在传输层进行数据分段，到了IP层就不用分片。而我们常提到的IP分片是由于比如UDP传输协议造成的，因为UDP传输协议并未限定传输数据报的大小。</p><h3 id="3-流量控制（Data-Flow-Control）"><a href="#3-流量控制（Data-Flow-Control）" class="headerlink" title="3.流量控制（Data Flow Control）"></a>3.流量控制（Data Flow Control）</h3><p>TCP的传输要保证数据能够准确到达目的地，如果不能，需要能检测出来并且重新发送数据。每一台设备都有自己的承载能力，如果发送方发送数据的速度超过了接收方处理数据的速度，那超过的那部分就会被丢弃，发送方一定时间内检测不到接收方回复的ACK，就会重新发送被丢弃的那些数据。为了提高效率，避免发送方发送速度太快，导致的重发，TCP引入了滑动窗口机制。</p><h4 id="3-1-滑动窗口"><a href="#3-1-滑动窗口" class="headerlink" title="3.1 滑动窗口"></a>3.1 滑动窗口</h4><p>早前TCP为了保证可靠性采用的单次发生一个包，然后开启定时器，如果定时时间内收不到接收方ACK就重新发送刚才的包，等收到ACK后再发送下一个包，显然这样效率是很低的。 那如何一次可以发送多个包，并且不超过接收方处理数据的能力呢，滑动窗口可以解决类似问题。</p><p>所谓滑动窗口就是可变的窗口。</p><h4 id="3-1-发送窗口"><a href="#3-1-发送窗口" class="headerlink" title="3.1 发送窗口"></a>3.1 发送窗口</h4><p>发送窗口根据数据包状态划分大致划分四类</p><ul><li><strong>已回复</strong> 已经收到接收方ACK的数据包</li><li><strong>等待回复</strong> 已经发送出去的数据包，但是没有收到ACK</li><li><strong>尽快发送</strong> 准备发送的数据包</li><li><strong>未发送</strong> 当TCP层收到应用层数据达到MSS值就会组装一个数据包，按序排列，这部分的数据包属于已组装但是超过接收方接收能力的数据包。</li></ul><p>图一：</p><p><img src="https://github.com/sun6boys/Documents/blob/master/Resources/fasongchuankou1.png?raw=true" alt="icon"></p><p>接收方和发送方建立连接后，接收方通过TCP header中window（字节）告知发送方我现在可以处理4个数据包，滑动窗口挪至1-4编号的位置，并将这4个包立即发送。</p><p>图二：<br><img src="https://github.com/sun6boys/Documents/blob/master/Resources/fasongchuangkou3.png?raw=true" alt="icon"></p><p>接收方发送1-4数据包，如果等不到ACK需要重新发送，所以缓存下来，1-4号包状态变成等待回复。</p><p>图三：<br><img src="https://github.com/sun6boys/Documents/blob/master/Resources/fasongchuangkou2.png?raw=true" alt="icon"></p><p>接收方给第1-2个包ACK了，并告知发送方，我现在还可以处理3个数据包，随机滑动窗口挪至3-7的区域。并将5-7的包发送出去。1-2号包会在发送缓存即将满时清除。</p><p>窗口以字节为单位，此处举例暂忽略，此处也忽略了TCP拥塞控制，会在第四章节介绍。</p><h4 id="3-2-接收窗口"><a href="#3-2-接收窗口" class="headerlink" title="3.2 接收窗口"></a>3.2 接收窗口</h4><p>接收端也有一个接收窗口，有3个分类</p><ul><li><strong>接收并且已经回复，但是还没被应用层接收</strong></li><li><strong>已经接收，但是还没有ACK的</strong> 这部分数据可能是由于前面有一个包没有收到，所以不可以ACK，或者在等待后续的数据包，对一组数据一起ACK。</li><li><strong>空位</strong> 还没有被接收的数据</li></ul><h4 id="3-3-ACK"><a href="#3-3-ACK" class="headerlink" title="3.3 ACK"></a>3.3 ACK</h4><h5 id="SACK-选择性确认"><a href="#SACK-选择性确认" class="headerlink" title="SACK 选择性确认"></a>SACK 选择性确认</h5><p>TCP并不是对每个包都会回复ACK，可能对2个及以上的包发送一个ACK。比如发送方发送1、2、3个数据包，接收方收到了2、3的包，接收方期望收到1号包，此时接收方会把2号和3号包放在缓存当中，等待接收1号包，如果1号包一直收不到那2号和3号包也会被丢弃，如果接收到1号包，那会对这3个包进行一次确认。</p><p>上面流程中间因为接收方没收到1号包，但是收到2号3号包，所以接收方要告诉发送方我期望收到1号包，发送方把1号包及后续的包（2号3号）发送给接收方，这样原先已经正确传输的包就重复发送了，如此便降低了TCP性能。为了改善这种情况发展了SACK(Selective Acknowledgment, 选择性确认)。</p><p>SACK信息是通过TCP头的选项部分提供的，信息分两种，一种标识是否支持SACK，是在TCP握手时发送；另一种是具体的SACK信息。 </p><ul><li><strong>SACK 允许选项</strong> 在TCP握手的包中，控制标识SYN 为1的数据包header当中的option中标识各自是否支持SACK 类型为4.</li><li><strong>SACK 选项</strong> 在option中类型为5 告诉发送方接收到并缓存的数据块，由此发送方会检查哪个数据包丢失。</li></ul><p>如果上述场景中双方都支持SACK，那接收方就会告诉发送方我已经缓存了2，3号包，那发送方就只会重新发送1号包，接收方收到1号包会给1-3号包一次确认。</p><h3 id="4-拥塞控制"><a href="#4-拥塞控制" class="headerlink" title="4.拥塞控制"></a>4.拥塞控制</h3><p>网络上数据传输会经过很多物理设备（路由器，光纤），这些设备都有最大负载能力，一旦通过的数据超过了设备的处理能力，便会抛弃这些数据。这也被称作为网络拥塞。<br>出现资源拥塞的条件 是对资源需求综合 &gt; 可用资源，比如50M带宽，同一时间需要通过数据量大于50M就会出现拥塞。 </p><h4 id="4-1-慢启动-amp-拥塞避免"><a href="#4-1-慢启动-amp-拥塞避免" class="headerlink" title="4.1 慢启动&amp;拥塞避免"></a>4.1 慢启动&amp;拥塞避免</h4><p>每当发送方和接收方建立连接后，发送方不知道当前网络状况，会先缓慢的发送数据包，单次逐渐增加发送数据包的数量，直到发现丢包，再降低发送速率，依次增加速率。</p><p>发送方维持<strong>拥塞窗口 cwnd</strong>，发送方控制拥塞窗口原则是：</p><ul><li>只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。</li><li>只要网络出现拥塞，拥塞窗口就减小一些，以减小注入到网络中的分组数。</li></ul><p>慢启动&amp;拥塞避免过程图：</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1514652703610&amp;di=1426e92f74fbb9b0715834c4bf50580a&amp;imgtype=0&amp;src=http%3A%2F%2Fimages2015.cnblogs.com%2Fblog%2F833931%2F201611%2F833931-20161122000021596-1751581103.jpg" alt="icon"></p><p>慢启动&amp;拥塞避免过程介绍：</p><ol><li>如图发送方第五轮依次发送1个、2个、4个、8个、16个数据包。</li><li>第四轮发送数据包达到了<strong>慢启动门限初始值（默认16）</strong>进入拥塞避免阶段，之后依次多增加一个包，而不是像前几轮指数增加。</li><li>第12轮发送24个包后，发现有丢包现象，设置新的<strong>慢启动门限</strong>为12，（发现丢包时单次发送包的数量除以2即24/2）</li><li>第13轮重新开始慢启动流程，指数增加窗口至12.</li><li>17轮达到新的<strong>慢启动门限</strong>再次进入拥塞避免 开始依次增加一个包。</li><li>…</li></ol><p><strong>拥塞避免</strong>并非完全能够避免了拥塞。利用以上的措施要完全避免拥塞是不可能的。<strong>拥塞避免</strong>是说在拥塞避免阶段把拥塞窗口控制为按线性增长，使得网络不容易出现拥塞。</p><h4 id="4-2-快重传"><a href="#4-2-快重传" class="headerlink" title="4.2 快重传"></a>4.2 快重传</h4><p>在<strong>拥塞避免算法</strong>后提出来的拥塞控制算法。</p><p>举例：A(发送方)—-B（接收方）</p><ol><li>A发送N个号包至B</li><li>B收到1号包回复ACK(要求发送2)</li><li>B收到2号包回复ACK(要求发送3)</li><li>B收到4号包回复ACK(要求发送3)</li><li>B收到5号包回复ACK(要求发送3)</li><li>B收到6号包回复ACK(要求发送3)</li><li>…</li></ol><p>第3步中是正确的ACK，第4步中A又收到了同样的ACK，此时A应该会怀疑3号包丢了，但是也有可能是乱序造成的，所以A继续观望（如果双方支持SACK，那此时A是知道B收到了4号包）。第五步中A又同样的收到了ACK，A继续观望，可能在后面一段时间B就会收到3号包了，第6步中A又收到同样的ACK，此时A会认为丢包概率很大立即启动快重传，重新发送3号包。</p><p>快重传中冗余ACK（不包括第一个正常的）数量设置为3个启动快重传，可能因为设计者认为包乱序的概率不算低，2次冗余ACK意味着丢包概率50%乱序概率50%，而3次冗余ACK丢包的概率就大于50%了，所以立即启动重传。</p><h4 id="4-2-快恢复"><a href="#4-2-快恢复" class="headerlink" title="4.2 快恢复"></a>4.2 快恢复</h4><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2039823993,149183578&amp;fm=15&amp;gp=0.jpg" alt="icon"></p><p>发送方收到3个冗余ACK，判断丢可能包了，启动快重传，拥塞窗口并不会重新进入慢开始，而是进入快恢复，如上图。为什么直接进入快恢复我猜测既然发送方收到3个冗余ACK说明网络环境尚可。</p><blockquote><p>上文流量控制中说到发送方发送窗口大小会因接收方接收窗口影响，显然这一章介绍得出发送窗口也由拥塞窗口决定，综上所述得出 发送窗口 = MIN（接收方窗口，发送方拥塞窗口）</p></blockquote><hr><p>由本文可见MSS和ACK才是TCP称为可靠的主要原因，拥塞控制和流量控制只是为了保障可靠性提高效率的策略。</p><p>TCP建立连接的三次握手和断开连接的四次握手这里没有介绍。TCP之所以也被称为面向连接，因为接收方和发送方一旦建立连接需要专门为对方开辟资源处理对方的数据，直至断开连接。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">TCP/IP详解</a></p><p><a href="http://blog.csdn.net/wdscq1234/article/details/52444277" target="_blank" rel="noopener">TCP/IP详解：滑动窗口</a></p><p>stackoverflow及知乎等</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>下面是github源文件地址，如果发现文字阐述有误或者理解错误的地方，您可以提Issues或Pull Request,谢谢您的阅读。<br><a href="https://github.com/sun6boys/Documents/blob/master/2.TCP:UDP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">源文件地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前大多数app和服务器通信的时候才有的HTTP应用层协议，而HTTP又是TCP协议实现的，所以TCP协议的重要性不言而喻。TCP是一个传输层协议位于IP协议网络层之上。从很多书籍和资料上解释TCP是可靠的传输层协议。结合下面的内容就会得到分析为什么TCP协议是可靠的传输层
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IP协议小叙</title>
    <link href="http://charonchu.club/2017/12/31/IP%E5%8D%8F%E8%AE%AE%E5%B0%8F%E5%8F%99/"/>
    <id>http://charonchu.club/2017/12/31/IP协议小叙/</id>
    <published>2017-12-30T16:47:15.000Z</published>
    <updated>2017-12-30T16:48:26.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP协议总结"><a href="#IP协议总结" class="headerlink" title="IP协议总结"></a>IP协议总结</h1><h2 id="1、什么是IP协议"><a href="#1、什么是IP协议" class="headerlink" title="1、什么是IP协议"></a>1、什么是IP协议</h2><p>Internet Protocol应用于OSI参考模型中网络层，主要应用于在相互连接的网络之间传递IP数据包。</p><h2 id="2、基础概念"><a href="#2、基础概念" class="headerlink" title="2、基础概念"></a>2、基础概念</h2><h3 id="2-1-IP地址"><a href="#2-1-IP地址" class="headerlink" title="2.1 IP地址"></a>2.1 IP地址</h3><p>接入互联网的每一个主机（或路由器）的每一个接口会分配一个在全世界范围的唯一的32位二进制标示符（IPV4）<strong>IPV6是128位，下面叙述只针对IPV4</strong></p><p>例如：<code>11010010010010011000110000000010</code><br>为了方便理解和记忆把地址分成4段，每段是8位，中间以小数点隔开。</p><p>变成这样：<code>11010010.01001001.10001100.00000010</code><br>显然这样也不太容易记住，于是将每段中的八位二进制转成十进制</p><p>最终是这样：<code>210.73.140.2</code></p><h4 id="2-1-1-网络号-主机号"><a href="#2-1-1-网络号-主机号" class="headerlink" title="2.1.1 网络号/主机号"></a>2.1.1 网络号/主机号</h4><p>为了方便IP地址的管理以及解决IP地址分配捉襟见肘的问题，每个IP地址分割成<strong>网络号</strong>和<strong>主机号</strong>。</p><ul><li><strong>网络号</strong>表示主机（或路由器）所以链接的网络，一个网络号在整个因特网范围内是唯一的。</li><li><strong>主机号</strong>表示该网络段的某一台主机或者路由器编号，在该网络段内它也是唯一的。</li></ul><p>以32位二进制Ip地址为例<code>11010010010010011000110000000010</code></p><p>如果前8位是网络号，那后面剩下的24位为主机号。又或者前24位是网络号那后面8位是主机号。一个IP地址除去前面的网络号，后面剩下的都是主机号。</p><p>不同的网段的网络号不一样，不同的IP地址前面多少位是网络号也不一定是一样的。</p><p>那如何知道一个IP地址的网络号是多少（或者说前多少位是网络号），这里就要涉及到子网掩码。</p><h4 id="2-1-2-子网掩码"><a href="#2-1-2-子网掩码" class="headerlink" title="2.1.2 子网掩码"></a>2.1.2 子网掩码</h4><p>经常配置网络子网掩码的同学，一定对<strong>255.255.255.0</strong>特别熟悉，这里就以<strong>255.255.255.0</strong>为例，将它转成二进制 <code>11111111 11111111 11111111 00000000</code>该子网掩码经转换后就是24个1，加8个0，代表着IP地址前24位代表网络号后8位代表主机号。</p><p>有些IP地址会用（<em>nix表示法），比如<code>192.9.200.13/24</code>代表 <strong>192.9.200.13</strong>前24位是网络号 和子网掩码<em>*255.255.255.0</em></em>意思一致。</p><h6 id="如何计算网络地址？这里用到与运算"><a href="#如何计算网络地址？这里用到与运算" class="headerlink" title="如何计算网络地址？这里用到与运算"></a>如何计算网络地址？这里用到与运算</h6><p>例如IP地址为：<strong>202.99.160.50</strong> 子网掩码是<strong>255.255.255.0</strong>，步骤如下</p><ol><li><p>将<strong>202.99.160.50</strong>转换成二进制  11001010 01100011 10100000 00110010</p></li><li><p>将<strong>255.255.255.0</strong> 转换成二进制  11111111 11111111 11111111 11111111</p></li><li><p>将二者与运算</p><p>11001010 01100011 10100000 00110010</p><p>11111111 11111111 11111111 00000000</p><p>———–与运算———————————-</p><p>11001010 01100011 10100000 00000000   转换成十进制202.99.160.0，这就是网络号</p></li></ol><h3 id="2-2-DNS"><a href="#2-2-DNS" class="headerlink" title="2.2 DNS"></a>2.2 DNS</h3><p>正常情况下我们访问网络上某一台服务器只需要知道它的IP地址就能连接上，但是即使是转换成十进制的二进制地址也是难以让人记住的，所以我们访问某个网站时更多的是在浏览器地址输入域名，但是在网络层只认IP不认域名，所以DNS服务器帮助我们把域名解析成IP地址。那DNS解析流程是怎么样的呢？这里会涉及到几个节点。</p><ul><li><strong>主机</strong>，某一个接入互联网的PC电脑</li><li><strong>本地DNS服务器</strong></li><li><strong>根域名服务器</strong></li><li><strong>顶级域名服务器（比如.com域名服务器）</strong></li><li><strong>具体域名服务器 (比如jd.com)</strong><code>这都是自己想的名词，有点怪</code></li></ul><p>例:用户在主机浏览器输入<code>www.jd.com</code>DNS解析流程如下</p><ol><li>主机先查询自己的hosts文件及本地DNS缓存，查询是否有和<code>www.jd.com</code>匹配的域名,查询到直接连接服务器，查询不到走2</li><li>客户端联系<strong>本地DNS服务器</strong>查询域名，如果没有<strong>本地DNS服务器</strong>会请求<strong>根域名服务器</strong></li><li><strong>根域名服务器</strong>如果也查询不到相应的配置，会返回<code>.com的顶级域名服务器地址</code>给<strong>本地DNS服务器</strong></li><li><strong>本地DNS服务器</strong>请求<strong>.com域名服务器</strong>查询<code>www.jd.com</code>的IP地址，如果<strong>.com域名服务器</strong>也查询不到会返回<strong>jd.com的域名服务器</strong>的地址</li><li><strong>本地DNS服务器</strong>请求<strong>jd.com的域名服务器</strong>，<strong>jd.com的域名服务器</strong>将IP地址返回给<strong>本地DNS服务器</strong></li><li><strong>本地DNS服务器</strong>将解析到的IP地址返回给<strong>主机</strong>，<strong>主机</strong>缓存该IP地址，下次再次连接<code>jd.com</code>会直接从缓存中获取到相应的IP地址</li></ol><h3 id="2-3-端口号"><a href="#2-3-端口号" class="headerlink" title="2.3 端口号"></a>2.3 端口号</h3><p>IP地址是一台主机在互联网中的标示，端口号是这台主机的唯一的一个程序的标识。所以如果需要和某台计算机建立连接的话，只需要知道IP地址或域名即可，但是如果想和该台计算机上的某个程序交换数据的话，还必须知道该程序使用的端口号。</p><p>端口号不属于网络层（IP协议）中的内容，它属于传输层中的内容，每个IP包在经过传输层打包的时候会在TCP/UDP header中添加源端口号和目标端口号。</p><h3 id="2-4-MAC地址"><a href="#2-4-MAC地址" class="headerlink" title="2.4 MAC地址"></a>2.4 MAC地址</h3><p>数据包经网络层处理完毕至数据链路层，因为数据链路层不认IP地址，所以需要用到MAC地址。</p><p>MAC地址是接入网络中主机或者路由器的标识，由网卡生成厂家在生产的时候就植入到芯片当中，每一个MAC地址都是唯一的。</p><p>数据帧在由路由器中传输的时候，会修改frame当中源mac地址为自己的mac地址，目的地mac地址为下一跳设备的mac地址。</p><p>所以数据包在每经过一个路由器的时候源mac地址和目标mac地址都会改变，记得我们团队当时做接口防刷，有人提出通过记录请求的MAC地址来达到防刷目的，事实上这样是不可行的，除非在HTTP header中添加源主机的MAC地址。</p><h3 id="2-5-ARP协议"><a href="#2-5-ARP协议" class="headerlink" title="2.5 ARP协议"></a>2.5 ARP协议</h3><p>如果同一个网络段内2台主机传输数据就必须知道对方的MAC地址，如果是不同网段内发送请求的主机也必须知道上一网关（路由器）的mac地址。那如何知道对方的MAC地址呢？</p><p>A主机向B主机发送数据，首先A主机肯定得知道B主机的IP地址，A主机先根据B主机的IP地址计算出网络号，如果网络号和自己一样，那说明是B和自己处于同一局域网下，A主机会在局域网内发送一个ARP广播，内容大致是<strong>这个IP地址的主机MAC地址是什么</strong>，同一局域网内的主机都会收到这个广播，B主机接到该广播消息，一看这不是我的IP地址么，于是就回复该广播消息我的MAC地址是xxx，A主机收到B主机回复的消息，于是在链路层header中的源MAC地址写上自己的MAC地址，目标MAC地址写上B主机的MAC地址，这样数据就开始发送了。收到B主机的回复消息A主机会缓存B主机IP地址和它MAC地址的映射关系，下次再给B发送消息就不用再发送ARP广播了。</p><p>如果A主机算出B主机网络号和自己不是同一网段，A主机会给网关（路由器）定向发送ARP消息，问网关的MAC地址，网关回复A主机它的MAC地址，A主机在链路层header中的源MAC地址写上网关的MAC地址，然后把数据交给网关。</p><h3 id="2-6-路由表-Routing-Table"><a href="#2-6-路由表-Routing-Table" class="headerlink" title="2.6 路由表(Routing Table)"></a>2.6 路由表(Routing Table)</h3><p>互联网中2个主机通信，A主机要找到B主机，中间可能会经过好多个路由器，就像现实中从上海到北京一样，如果拿着地图，可以很方便的找到从上海到达北京的路径。路由表就是网络传输中的地图，只是它（<strong>动态路由</strong>）有时不像现实地图那样一眼就能知道全路程怎么走，它有时候只知道下一站是什么，就像单向链表一样，每个节点只知道自己下一个节点，但是最终也能找到尾节点。</p><ul><li>路由器有多个接口，因为路由器主要功能是隔离网段所以每个接口的网段肯定不一样。</li><li>默认路由器只知道直连的路由信息。</li><li>路由器必须通过某种方式获知非直连路由。</li></ul><p>那如何知道路由器如何知道非直连路由呢？</p><ol><li><p><strong>静态路由</strong>由管理员手动配置路由表，比如从网段1 到网段2 需要经过哪几个路由器的哪几个接口都需要手动配置。</p><p>   优点：</p><ul><li>占用路由器资源小</li><li>可以严格控制路由转发</li><li>支持广泛</li></ul><p>缺点：</p><ul><li>出现网络拓扑变动时还需要管理员手动去更新</li><li>当网络很大时配置维护比较复杂</li></ul><p>所以静态路由只适合一些小型网络，或者需要严格策略控制的网络。</p><p>路由表只匹配网络段，不匹配主机段。如果现在管理员在路由表中配置了3条路由分别是：</p><ul><li>192.168.1.128/30</li><li>192.168.1.0/24</li><li>192.168.0.0/16</li></ul><p>现在有一个数据包是发到<code>192.168.1.129</code>,现在分别与这3条路由去匹配，显然第一条路由信息只匹配前30位能够匹配上，第二条路由匹配前24位也能匹配上，同理第3条也能匹配上，但是路由器会选择第一条。 因为路由器会选择匹配位数最高的那一条路由。</p><p>路由器匹配到一个路由信息，必须找到一个出接口才能进行转发，如果没有匹配到路由会丢弃数据包，并向源返回一个ICMP报错信息。</p></li><li><p><strong>动态路由</strong>如果是一个大型网络，网络当中有成百上千个路由器，显然用静态配置路由的方式会很困难，这里就要采用动态路由协议。动态路由协议实际上市运行在路由器上的一个软件，相同的动态路由协议通过在不同的路由器之间交换该动态路由协议规定的数据包来交换各自的路由信息，从而达到学习路由、维护路由表、发现网络拓扑变动的目的。</p></li></ol><p> <img src="https://raw.githubusercontent.com/sun6boys/Documents/master/Resources/routingScreenshot.png" alt="icon"></p><p>  上面提到<code>默认路由器只知道直连的路由信息。</code>所以路由器A是知道我的s0/0/0接口是连接10.2.0.0网段的的，同理B也知道我的s0/0/0接口连接10.3.0.0网段的，通过动态路由协议，路由器A告诉路由器B，我还有一个fa0/0接口是连接10.1.0.0网段的，路由器B告诉路由器C我有一个接口是连接10.2.0.0网段的，并且路由器A有一个接口是连接10.1.0.0网段的，通过动态学习3个路由器都知道了相互的链接信息，并且把信息缓存在路由表中。</p><h2 id="3、分片和重组"><a href="#3、分片和重组" class="headerlink" title="3、分片和重组"></a>3、分片和重组</h2><p>说到分段重组不得不提一个很重要的概念MTU，它也是造成IP协议分段和重组的原因。</p><h3 id="3-1-MTU"><a href="#3-1-MTU" class="headerlink" title="3.1 MTU"></a>3.1 MTU</h3><p>当2台主机在网络中通信的时候，数据包会穿过各种路由器和物理媒介，不同的媒介都限制了单个数据包能通过自己的最大体积，这就是MTU<strong>最大传输单元</strong>,2台主机在传输数据前IP协议会事先确定MTU。</p><h3 id="3-2-IP分片"><a href="#3-2-IP分片" class="headerlink" title="3.2 IP分片"></a>3.2 IP分片</h3><p>如果一个数据包的体积超过了MTU传输，转发设备就会根据要求丢弃这个数据包，然后返回一个错误信息给发送者，这样会造成某些通讯上的问题。</p><h4 id="3-2-1-什么是IP分片？"><a href="#3-2-1-什么是IP分片？" class="headerlink" title="3.2.1 什么是IP分片？"></a>3.2.1 什么是IP分片？</h4><p>IP协议在传输数据包时，将数据包分为若干段（不超过MTU）大小进行传输，并在目标系统中进行重组。这个过程称为分片。</p><h4 id="3-2-2-分片原理"><a href="#3-2-2-分片原理" class="headerlink" title="3.2.2 分片原理"></a>3.2.2 分片原理</h4><p>这里介绍下IP报头的主要内容，如图所示<br><img src="http://img.blog.csdn.net/20170301092349308" alt="icon"></p><ul><li><strong>版本</strong> IP协议的版本，IPV4 或者IPV6</li><li><strong>首部长度</strong> IP报头长度最小20字节 最大60字节，所以可变长度是40字节</li><li><strong>总长度</strong> IP报头长度与数据部分长度之和（不超过MTU）</li><li><strong>标识</strong> 目标主机可能会同时接收好几台主机给他发来的数据，所以需要给某次传输的数据标示，避免目标主机将2个不相关的数据包进行重组</li><li><strong>位偏移</strong> 该分片数据包相对于完整数据包首位的偏移位，避免目标主机重组时乱序</li><li><strong>源地址</strong> 发送主机IP地址</li><li><strong>目的地址</strong> 目标主机IP地址</li><li>…..</li></ul><p>IP分片和完整IP报文差不多拥有相同的IP头，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位识别号唯一记录了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而13位片偏移则记录了某IP片相对整个包的位置；而这表中间的<strong>标志</strong>则标志着该分片后面是否还有新的分片。接受方就可以利用这些信息对IP数据进行重新组织。</p><h3 id="3-3-重组"><a href="#3-3-重组" class="headerlink" title="3.3 重组"></a>3.3 重组</h3><p>正如上面所说，<strong>标识</strong> 是分片前的完整数据包的ID，<strong>位偏移</strong>是分片的数据包基于分片前数据包的偏移位。<br>打比方 <strong>标识</strong>代表的班级名称，<strong>位偏移</strong>代表班级某学生的编号，如果校长现在要将学生按照班级排列，并且同一个班级的学生要按照编号排位，那他只要知道每个学生是哪个班级以及编号是多少即可。</p><hr><p>TCP/IP 是一个庞大的系统网络工程，几年前读过《TCP/IP协议族》这本书，很多知识都一知半懂，现在回过头写这些总结很多概念都已经忘记了。这篇文章介绍的部分知识虽然只是IP协议相关知识的九牛一毛，但是如果能给您带来哪怕一点点帮助，我都会很开心的。</p><p>这篇文章的介绍很多都是靠我自己的理解来阐述出来，可能有一些理解有误的地方，如果您发现了错误的地方，下面是github源文件地址，您可以提Issues或Pull Request,谢谢您的阅读。<br><a href="https://github.com/sun6boys/Documents/blob/master/1.IP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">源文件地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IP协议总结&quot;&gt;&lt;a href=&quot;#IP协议总结&quot; class=&quot;headerlink&quot; title=&quot;IP协议总结&quot;&gt;&lt;/a&gt;IP协议总结&lt;/h1&gt;&lt;h2 id=&quot;1、什么是IP协议&quot;&gt;&lt;a href=&quot;#1、什么是IP协议&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>firstPage</title>
    <link href="http://charonchu.club/2017/10/09/firstPage/"/>
    <id>http://charonchu.club/2017/10/09/firstPage/</id>
    <published>2017-10-09T13:49:56.000Z</published>
    <updated>2017-10-09T13:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is my first page</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This is my first page&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://charonchu.club/2017/10/09/hello-world/"/>
    <id>http://charonchu.club/2017/10/09/hello-world/</id>
    <published>2017-10-09T13:03:51.000Z</published>
    <updated>2017-10-09T13:03:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
