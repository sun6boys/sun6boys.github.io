<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Charon的小窝</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://charonchu.club/"/>
  <updated>2018-01-11T15:05:52.136Z</updated>
  <id>http://charonchu.club/</id>
  
  <author>
    <name>Charon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Objective-c的类与对象</title>
    <link href="http://charonchu.club/2018/01/11/Objective-c%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>http://charonchu.club/2018/01/11/Objective-c的类与对象/</id>
    <published>2018-01-11T15:05:10.000Z</published>
    <updated>2018-01-11T15:05:52.136Z</updated>
    
    <content type="html"><![CDATA[<p>从编程发展史来看，早期软件比较简单，我们只需要面向过程编程：</p><ul><li>定义函数</li><li>定义数据</li><li>各种函数和数据的操作</li></ul><p>当软件发展起来，软件越来越大，代码量也越来越大，我们的编写就有麻烦了：</p><ul><li>函数越来越多，命名容易冲突。</li><li>代码重复</li><li>变量生命周期难以管理</li></ul><p>为了解决上述问题面向对象思想呼之而来。</p><h3 id="1-类、对象与模块"><a href="#1-类、对象与模块" class="headerlink" title="1. 类、对象与模块"></a>1. 类、对象与模块</h3><p>面向对象从传统意义上的解释是封装，继承和多态。打个比方现在需要盖一栋房子，分为三个步骤：</p><ul><li>打地基<ul><li>需要用到工种：钢筋工、瓦工</li><li>需要用到的材料：混凝土、钢筋</li></ul></li><li>砌墙体<ul><li>需要用到工种：瓦工</li><li>需要用到的材料：砖、混凝土</li></ul></li><li>盖屋顶<ul><li>需要用到的工种：木工、瓦工</li><li>需要用到的材料：木头、瓦片、混凝土</li></ul></li></ul><p>这几个步骤抽象出来：钢筋工、瓦工、木工、混凝土、钢筋、砖、瓦片等，然后你发现钢筋工、瓦工、木工有共同的行为行为work（干活），于是抽象出一个工人。砖、混凝土、钢筋、瓦片也有一些共同特性比如膨胀系数等，然后就从中衍生出抽象。</p><ul><li>遇到重复的逻辑，可实现抽象。</li><li>粒度，即如果只被依赖某一部分，则表明可继续分解。</li></ul><p><strong>递归是编程当中一个重要思想，递归当中有终止条件，模块设计与抽象（或函数调用）也有终止条件，否则如上所说，砖、混凝土、钢筋、瓦片还可以抽象出分子原子，但这对我们是毫无意义的。终止条件是什么，这个是靠靠工程师的经验来判断</strong></p><p>砖、混凝土、钢筋、瓦片从这个例子当中只有一些特性，没有行为，我认为算是一种数据结构不能称之为模块，而钢筋工、瓦工、木工会有work的行为，那这便可以称之模块。打地基、砌墙体、盖屋顶需要对一些模块以及数据结构进行处理，可以称之为复合或复杂性模块。之后盖房子也抽象出一个模块由打地基、砌墙体、盖屋顶三个模块构成。</p><p>由类创建出来的实例称为对象。</p><h3 id="2-OC中的对象"><a href="#2-OC中的对象" class="headerlink" title="2. OC中的对象"></a>2. OC中的对象</h3><p>上一章介绍的类和对象抽象描述。从物理层面上一个对象在内存当中的形态是怎样呢？</p><h5 id="数组的物理形态"><a href="#数组的物理形态" class="headerlink" title="数组的物理形态"></a>数组的物理形态</h5><p>这里先介绍下<code>数组</code>在内存当中的形态。以64位操作系统，且存放对象的数组为前提。</p><p><img src="https://github.com/sun6boys/Documents/blob/master/Resources/array.png?raw=true" alt="icon"></p><p>如上图所示，数组的本质是一块连续内存，从array基地址第0-8个字节存放第一个元素的地址，第9-16个字节存放第二个元素的地址……</p><p>所以当我们用array[x] 取对象时会从array基地址 + x <em> 8字节 ~ array基地址 + （x + 1） </em> 8的内存中取出内容即为该对象的地址。</p><h5 id="OC对象的物理形态"><a href="#OC对象的物理形态" class="headerlink" title="OC对象的物理形态"></a>OC对象的物理形态</h5><p>假如现在定义一个Person类如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line">&#123;</div><div class="line">    NSString *_name;</div><div class="line">    NSUInteger _age;</div><div class="line">    NSString *_sex；</div><div class="line">&#125;</div><div class="line">@property (nonatomic,copy) NSString *name;</div><div class="line">@property (nonatomic, assign) NSUInteger age;</div><div class="line">@property (nonatomic, copy) NSString *sex;</div><div class="line">@end</div></pre></td></tr></table></figure><p>那由Person类构建出来的person实例在内存当中的结构如下图，第一个isa是Person基类NSObject的成员变量。</p><p><img src="https://github.com/sun6boys/Documents/blob/master/Resources/instance.png?raw=true" alt="icon"></p><p>也就是说，一个实例对象的内存大小，由自己本身的成员变量数量和父类成员变量数量，父类的父类一直到基类NSObject的成员变量数量总和决定的，一个成员变量分配8个字节（64位操作系统） 即使如NSUInteger这样的基本数据类型，也是分配的8个字节。我们可以通过<code>class_getInstanceSize</code>获取类的实例对象的内存大小</p><p>如果把person当成一个数组person.name 等同于person[1]，</p><blockquote><p>Objective-c是一个动态语言，可以在运行时添加方法或者交换方法等，但我们都知道一旦类注册后，便不能添加成员变量（包括category中也不能添加成员变量），这是因为如果可以随意添加成员变量，那在添加前创建的实例的内存大小由原先的成员变量数量决定，如果用老实例对象获取新成员变量一定会造成类似数组越界的野指针问题。除非苹果设计成类似数组那样当数组中元素数量达到扩容因子数值，重新开辟一块更大的内存，把原先的内容复制过去，但这好像不太现实。。。</p></blockquote><p>Objcetive-c中的对象即使如NSProxy或者block，内存当中头8个字节一定存放的是名为isa指针。那isa是什么呢？我如何知道第9-16个字节存放的是哪个成员变量的地址呢？</p><h5 id="isa"><a href="#isa" class="headerlink" title="isa"></a>isa</h5><p>isa可以理解成身份证明，每个实例对象的isa指针指向它所属的类（[person class]）,它是运行时环境加载完成便构建出来存放在内存data段。它是个结构体，也被称为类对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;</div><div class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</div><div class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</div><div class="line">    long version                                             OBJC2_UNAVAILABLE;</div><div class="line">    long info                                                OBJC2_UNAVAILABLE;</div><div class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure><ul><li><strong>Class _Nonnull isa</strong> 类对象头8个字节也是一个isa指针，所以它也是一个对象，它指向的是meta class（此处略过不表）</li><li><strong>Class super_class</strong> 父类对象的指针</li><li><strong>const char name</strong> 类名</li><li><strong>long version</strong> 类的版本信息</li><li><strong>long instance_size</strong> 实例对象所占内存大小</li><li><strong>ivars</strong> 成员变量集合</li><li><strong>methodLists</strong> 实例方法列表</li><li><strong>cache</strong> 最近调用的方法列表</li><li><strong>protocols</strong> 协议列表</li></ul><blockquote><p>Runtime的一些知识网上较多，此处略过不表，可以去查询比如oc中函数如何调用，交换方法，meta class等知识。</p></blockquote><p>类对象当中<code>objc_ivar_list</code>存放的成员变量的集合<code>objc_ivar</code>,上一小节中提到person.name是如何知道name的存放地址距person基地址偏移量呢 ，可以通过<code>ivar_getOffset</code>来获得具体的偏移量。</p><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>本文讲述了类的抽象描述以及OC对象的内存形态。如果您通过这篇文章知道下面<code>void *p</code>为什么会被当做Person的实例对象，那我的目的便达到了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class personClass = [Person class];</div><div class="line">void *p = &amp;personClass;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从编程发展史来看，早期软件比较简单，我们只需要面向过程编程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义函数&lt;/li&gt;
&lt;li&gt;定义数据&lt;/li&gt;
&lt;li&gt;各种函数和数据的操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当软件发展起来，软件越来越大，代码量也越来越大，我们的编写就有麻烦了：&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP协议小叙</title>
    <link href="http://charonchu.club/2018/01/07/HTTP%E5%8D%8F%E8%AE%AE%E5%B0%8F%E5%8F%99/"/>
    <id>http://charonchu.club/2018/01/07/HTTP协议小叙/</id>
    <published>2018-01-07T13:03:16.000Z</published>
    <updated>2018-01-07T13:03:55.689Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP(HyperText Transfer Protocol)是一套计算机通过网络进行通信的规则。计算机专家设计出HTTP，使HTTP客户（如Web浏览器）能够从HTTP服务器(Web服务器)请求信息和服务。HTTP遵循请求(Request)/应答(Response)模型。Web浏览器向Web服务器发送请求，Web服务器处理请求并返回适当的应答。所有HTTP连接都被构造成一套请求和应答。</p><h2 id="1-Request"><a href="#1-Request" class="headerlink" title="1. Request"></a>1. Request</h2><p>HTTP请求报文由三部分组成分别是<code>request line</code>、<code>request header</code>、<code>request body</code> 下图是一个实际的请求报文</p><p><img src="http://dl.iteye.com/upload/attachment/0069/3451/412b4451-2738-3ebc-b1f6-a0cc13b9697b.jpg" alt="icon"></p><h3 id="1-1-request-line-请求行"><a href="#1-1-request-line-请求行" class="headerlink" title="1.1 request line 请求行"></a>1.1 request line 请求行</h3><p>如上图中第一行中显示，请求行的内容包含了<code>请求方法</code>、<code>请求URI</code>以及<code>HTTP协议版本号</code></p><h4 id="1-1-1-请求方法"><a href="#1-1-1-请求方法" class="headerlink" title="1.1.1 请求方法"></a>1.1.1 请求方法</h4><p><code>GET</code></p><p>GET方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据。</p><p><code>POST</code></p><p>POST方法用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改。</p><p><code>HEAD</code></p><p>HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体。</p><p><code>PUT</code></p><p>PUT方法用请求有效载荷替换目标资源的所有当前表示。</p><p><code>DELETE</code></p><p>DELETE方法删除指定的资源。</p><p><code>CONNECT</code></p><p>CONNECT方法建立一个到由目标资源标识的服务器的隧道。</p><p><code>OPTIONS</code></p><p>OPTIONS方法用于描述目标资源的通信选项。</p><p><code>TRACE</code></p><p>TRACE方法沿着到目标资源的路径执行一个消息环回测试。</p><p><code>PATCH</code></p><p>PATCH方法用于对资源应用部分修改。</p><p>以上请求方法，笔者只用到过2个<code>GET</code>和<code>POST</code>，所以暂且只着重介绍这两种方法。在我理解上GET应该用于固定资源或者不常改动资源的获取比如新闻列表、中国省市区信息、图片资源等。POST用于可能会改变服务器上的资源的请求。在实际应用中GET和POST并没有严格遵守http规范，有的图方便更新资源时用了GET，包括对资源的增，删，改，查操作，其实都可以通过GET/POST完成，因此造就了应用开发当中一些不规范的操作。</p><h5 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h5><ol><li><p><strong>GET请求数据只能附在URL之后</strong></p><p>事实上GET请求参数也可以放在body当中，但是正常情况下是放在URL的QUERY中</p></li><li><p><strong>GET方式提交数据大小有限制</strong></p><p>实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。</p></li></ol><h5 id="GET和POST主要区别"><a href="#GET和POST主要区别" class="headerlink" title="GET和POST主要区别"></a>GET和POST主要区别</h5><table><thead><tr><th></th><th style="text-align:center">GET</th><th style="text-align:center">POST</th></tr></thead><tbody><tr><td>缓存</td><td style="text-align:center">可以被缓存</td><td style="text-align:center">不能缓存，If-Modified-Since ， If-None-Match等对其无效</td></tr><tr><td>编码类型</td><td style="text-align:center">application/x-www-form-urlencoded</td><td style="text-align:center">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td style="text-align:center">参数保留在浏览器历史中。</td><td style="text-align:center">参数不会保存在浏览器历史中。</td></tr><tr><td>对数据类型的限制</td><td style="text-align:center">只允许 ASCII 字符。</td><td style="text-align:center">没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td style="text-align:center"><strong>与 POST 相比</strong>，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td style="text-align:center">本质上POST也不安全，硬分个高低，POST <strong>比GET</strong>更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr></tbody></table><p>如果从HTTP规范定义方面来讲，POST是比GET安全性要低的，因为GET只能获取资源，POST可以修改资源。但是POST能做的事GET也能做到，所以其实在这方面不存在安全性高低的问题。另外一点GET请求参数跟在URL后面，可以被明眼看到，而且URL会保存在浏览器历史记录当中，POST请求参数在body当中不会被浏览器记录，但是POST其实通过一些抓包工具也能够轻易抓取body当中的数据，所以这2种方式安全性都很低，如果硬要分个高低，那POST确实比GET安全性高一些。</p><h4 id="1-1-2-请求URI"><a href="#1-1-2-请求URI" class="headerlink" title="1.1.2 请求URI"></a>1.1.2 请求URI</h4><p>统一资源标识符，用来唯一的标识一个资源，URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h4 id="1-1-3-HTTP协议版本号"><a href="#1-1-3-HTTP协议版本号" class="headerlink" title="1.1.3 HTTP协议版本号"></a>1.1.3 HTTP协议版本号</h4><p>http比较常用的版本是1.0、1.1、2.0</p><p><strong>http 1.1 与http 1.0主要区别</strong></p><ul><li><code>长连接</code> <strong>1.1</strong>默认开启开启长连接,只有当一方header当中connection 为close时才关闭连接。<strong>1.0版本</strong>通过Keep-Alive 可以延长链接，但是需要将 The Connection 首部的值设置为  “keep-alive” 这个首部才有意义。</li><li><code>HOST域</code>  HTTP1.1在Request消息头里头多了一个Host域，而且是必传的，HTTP1.0则没有这个域。在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址,但随着虚拟主机技术的发 展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</li><li><code>带宽优化</code> HTTP/1.1中在请求消息中引入了range头域，它支持只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。</li><li><code>状态码</code> http/1.1中新增了一些状态码，比如重定向3xx就添加了几个，具体不记得了。</li><li>…</li></ul><p><strong>http 2.0 与http 1.x 主要区别</strong></p><ul><li><code>多路复用</code> HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</li><li><code>数据压缩</code> HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，完成一个请求的效率就提高了。</li><li><code>服务器推送</code> 当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。客户端通过 RESET_STREAM 可以主动取消 Push，也可以使用一个简洁的 Cache Digest 来告诉服务器，哪些东西已经在缓存，因此服务器也就会知道哪些是客户端所需要的。</li><li>…</li></ul><h3 id="1-2-request-header-请求头"><a href="#1-2-request-header-请求头" class="headerlink" title="1.2 request header 请求头"></a>1.2 request header 请求头</h3><p>http请求头很多，1.1又比1.0新增了很多请求头，一些通用请求头也会出现在response header中。这里介绍一些常用特殊的请求头。</p><p><code>Accept</code> </p><p>用来告知客户端可以处理的内容类型,如text/html, application/json, application/xml等</p><p><code>Accept-Encoding</code></p><p>HTTP 请求头 Accept-Encoding 会将客户端能够理解的内容编码方式——通常是某种压缩算法——进行通知,如gzip</p><p><code>Accept-Language</code></p><p>求头允许客户端声明它可以理解的自然语言，以及优先选择的区域方言。如en-US。</p><p><code>Keep-Alive</code></p><p>Keep-Alive 是一个通用消息头，允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。如timeout=5, max=1000。需要将 The Connection 首部的值设置为  “keep-alive” 这个首部才有意义。</p><p><code>Connection</code></p><p>Connection 头（header） 决定当前的事务完成后，是否会关闭网络连接。如果该值是“keep-alive”或者不传，网络连接就是持久的，不会关闭，使得对同一个服务器的请求可以继续在该连接上完成，一旦一方该值为“close”即关闭连接。在HTTP/2 协议中， Connection 和 Keep-Alive  是被忽略的。</p><p><code>Cookie</code></p><p>Cookie 是一个请求首部，其中含有先前由服务器通过 Set-Cookie  首部投放并存储到客户端的 HTTP cookies。HTTP协议是无状态的，每当客户端第一次连接服务端，服务端会生成cookie 通过Set-Cookie 存储到客户端，客户端之后的每次请求都会在Cookie带上之前存储的数据。</p><p><code>Cache-Control</code> </p><p>通用消息头被用于在http 请求和响应中通过指定指令来实现缓存机制。常用：max-age=<seconds>，only-if-cached等</seconds></p><p><code>If-None-Match</code></p><p>是一个条件式请求首部。对于 GETGET 和 HEAD 请求方法来说，当且仅当服务器上没有任何资源的 ETag 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为  200  。对于  GET 和 HEAD 方法来说，当验证失败的时候，服务器端必须返回响应码 304 （Not Modified，未改变）。</p><p><code>If-Match</code></p><p>请求首部 If-Match 的使用表示这是一个条件请求。在请求方法为 GET 和 HEAD 的情况下，服务器仅在请求的资源满足此首部列出的 ETag 之一时才会返回资源。如果请求的条件不满足，那么需要返回  412 (Precondition Failed，先决条件失败) 响应。</p><p><code>If-Modified-Since</code></p><p>是一个条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200  。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的  304  响应。</p><p><code>...</code></p><h3 id="1-3-request-body-请求体"><a href="#1-3-request-body-请求体" class="headerlink" title="1.3 request body 请求体"></a>1.3 request body 请求体</h3><blockquote><p>The headers are terminated by a blank line (CRLF), marking the end of the list of headers and the beginning of the entity body.– 《HTTP The Definitive Guide》</p></blockquote><h2 id="1-Response"><a href="#1-Response" class="headerlink" title="1. Response"></a>1. Response</h2><p>HTTP响应报文由三部分组成分别是<code>status line</code>、<code>response header</code>、<code>response body</code> 如下图所示</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1515306651975&amp;di=ba581c8f68fbb7783b970dfcd639e415&amp;imgtype=0&amp;src=http%3A%2F%2Fimages2015.cnblogs.com%2Fblog%2F1160612%2F201707%2F1160612-20170723095548293-1040544837.png" alt="icon"></p><h3 id="2-1-Status-Line-状态行"><a href="#2-1-Status-Line-状态行" class="headerlink" title="2.1 Status Line 状态行"></a>2.1 Status Line 状态行</h3><p>response状态行中主要有2块内容<code>HTTP协议版本号</code>、<code>状态码</code></p><h4 id="2-1-1-状态码"><a href="#2-1-1-状态码" class="headerlink" title="2.1.1 状态码"></a>2.1.1 状态码</h4><p>HTTP状态码被分为了五大类，下面会对着五大类进行略微详细地介绍—不仅会介绍状态码，还会列出其对应的原因短语。尽管没有实际的规范对原因短语进行确切地说明，下面所列的都是HTTP/1.0规范所推荐的原因短语。</p><p><strong>100~199 信息性状态码</strong></p><table><thead><tr><th>状态码</th><th style="text-align:center">状态信息</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>100</td><td style="text-align:center">Continue</td><td style="text-align:center">信息型状态响应码表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略.（HTTP 1.1新）</td></tr><tr><td>101</td><td style="text-align:center">Switching Protocol</td><td style="text-align:center">表示服务器应客户端升级协议的请求（Upgrade请求头）正在进行协议切换。（HTTP 1.1新）</td></tr></tbody></table><p><strong>200~299 成功状态码</strong></p><table><thead><tr><th>状态码</th><th style="text-align:center">状态信息</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>200</td><td style="text-align:center">OK</td><td style="text-align:center">表明请求已经成功. 默认情况下状态码为200的响应可以被缓存。</td></tr><tr><td>202</td><td style="text-align:center">Accepted</td><td style="text-align:center">表示服务器端已经收到请求消息，但是尚未进行处理。但是对于请求的处理确实无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。这个状态码被设计用来将请求交由另外一个进程或者服务器来进行处理，或者是对请求进行批处理的情形。</td></tr><tr><td>203</td><td style="text-align:center">Non-Authoritative Information</td><td style="text-align:center">表示请求已经成功被响应，但是获得的负载与源头服务器的状态码为 200 (OK)的响应相比，经过了拥有转换功能的 proxy （代理服务器）的修改。（HTTP 1.1新）</td></tr><tr><td>204</td><td style="text-align:center">No Content</td><td style="text-align:center">表示目前请求成功，但客户端不需要更新其现有页面。204 响应默认是可以被缓存的。在响应中需要包含头信息 ETag。</td></tr><tr><td>205</td><td style="text-align:center">Reset Content</td><td style="text-align:center">用来通知客户端重置文档视图，比如清空表单内容、重置 canvas 状态或者刷新用户界面。（HTTP 1.1新）</td></tr><tr><td>206</td><td style="text-align:center">Partial Content</td><td style="text-align:center">成功状态响应代码表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的 Range 首部指定的。（HTTP 1.1新）</td></tr><tr><td>205</td><td style="text-align:center">Reset Content</td><td style="text-align:center">用来通知客户端重置文档视图，比如清空表单内容、重置 canvas 状态或者刷新用户界面。</td></tr></tbody></table><p><strong>300~399 重定向状态码</strong></p><table><thead><tr><th>状态码</th><th style="text-align:center">状态信息</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>300</td><td style="text-align:center">Multiple Choices</td><td style="text-align:center">是一个用来表示重定向的响应状态码，表示该请求拥有多种可能的响应。用户代理或者用户自身应该从中选择一个。由于没有如何进行选择的标准方法，这个状态码极少使用。</td></tr><tr><td>301</td><td style="text-align:center">Moved Permanently</td><td style="text-align:center">永久重定向 说明请求的资源已经被移动到了由 Location 头部指定的url上，是固定的不会再改变。搜索引擎会根据该响应修正。</td></tr><tr><td>302</td><td style="text-align:center">Found</td><td style="text-align:center">临时重定向状态码表明请求的资源被暂时的移动到了由Location 头部指定的 URL 上。浏览器会重定向到这个URL， 但是搜索引擎不会对该资源的链接进行更新 (In SEO-speak, it is said that the link-juice is not sent to the new URL)。</td></tr><tr><td>303</td><td style="text-align:center">See Other</td><td style="text-align:center">通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。</td></tr><tr><td>304</td><td style="text-align:center">Not Modified</td><td style="text-align:center">说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe），例如GET 或HEAD 或在请求中附带了头部信息： If-None-Match 或If-Modified-Since。如果是 200 OK ，响应会带有头部 Cache-Control, Content-Location, Date, ETag, Expires，和 Vary.</td></tr><tr><td>307</td><td style="text-align:center">Temporary Redirect</td><td style="text-align:center">表示重定向的响应状态码，说明请求的资源暂时地被移动到  Location 首部所指向的 URL 上。状态码 307 与 302 之间的唯一区别在于，当发送重定向请求的时候，307 状态码可以确保请求方法和消息主体不会发生变化。当响应状态码为 302 的时候，一些旧有的用户代理会错误地将请求方法转换为 GET：使用非 GET 请求方法而返回 302 状态码，Web 应用的运行状况是不可预测的；而返回 307 状态码时则是可预测的。对于 GET 请求来说，两种情况没有区别。</td></tr><tr><td>308</td><td style="text-align:center">Permanent Redirect</td><td style="text-align:center">（永久重定向）是表示重定向的响应状态码，说明请求的资源已经被永久的移动到了由 Location 首部指定的 URL 上。浏览器会进行重定向，同时搜索引擎也会更新其链接（用 SEO 的行话来说，意思是链接汁被传递到了新的 URL）。</td></tr></tbody></table><p><strong>400~499 客户端错误状态码</strong></p><table><thead><tr><th>状态码</th><th style="text-align:center">状态信息</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>400</td><td style="text-align:center">Bad Request</td><td style="text-align:center">请求出现语法错误。</td></tr><tr><td>401</td><td style="text-align:center">Unauthorized</td><td style="text-align:center">客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填 写合适的Authorization头后再次发出请求。</td></tr><tr><td>403</td><td style="text-align:center">Forbidden</td><td style="text-align:center">资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。</td></tr><tr><td>404</td><td style="text-align:center">Not Found</td><td style="text-align:center">无法找到指定位置的资源。这也是一个常用的应答。</td></tr><tr><td>405</td><td style="text-align:center">Method Not Allowed</td><td style="text-align:center">无请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新）</td></tr><tr><td>406</td><td style="text-align:center">Not Acceptable</td><td style="text-align:center">指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容（HTTP 1.1新）。</td></tr><tr><td>407</td><td style="text-align:center">Proxy Authentication Required</td><td style="text-align:center">无类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新）</td></tr><tr><td>408</td><td style="text-align:center">Request Timeout</td><td style="text-align:center">在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新）</td></tr><tr><td>409</td><td style="text-align:center">Conflict</td><td style="text-align:center">通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新）</td></tr><tr><td>410</td><td style="text-align:center">Gone</td><td style="text-align:center">所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而 404表示由于未知的原因文档不可用。（HTTP 1.1新）</td></tr><tr><td>411</td><td style="text-align:center">Length Required</td><td style="text-align:center">服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新）</td></tr><tr><td>412</td><td style="text-align:center">Precondition Failed</td><td style="text-align:center">请求头中指定的一些前提条件失败（HTTP 1.1新）。</td></tr><tr><td>413</td><td style="text-align:center">Request Entity Too Large</td><td style="text-align:center">目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1新）。</td></tr><tr><td>414</td><td style="text-align:center">Request URI Too Long</td><td style="text-align:center">URI太长（HTTP 1.1新）。</td></tr><tr><td>416</td><td style="text-align:center">Requested Range Not Satisfiable</td><td style="text-align:center">服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新）</td></tr></tbody></table><p><strong>500~599 服务器错误</strong></p><table><thead><tr><th>状态码</th><th style="text-align:center">状态信息</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>500</td><td style="text-align:center">Internal Server Error</td><td style="text-align:center">服务器遇到了意料不到的情况，不能完成客户的请求。</td></tr><tr><td>501</td><td style="text-align:center">Not Implemented</td><td style="text-align:center">服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。</td></tr><tr><td>502</td><td style="text-align:center">Bad Gateway</td><td style="text-align:center">服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。</td></tr><tr><td>503</td><td style="text-align:center">Service Unavailable</td><td style="text-align:center">服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个 Retry-After头。</td></tr><tr><td>504</td><td style="text-align:center">Gateway Timeout</td><td style="text-align:center">由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新）</td></tr><tr><td>505</td><td style="text-align:center">HTTP Version Not Supported</td><td style="text-align:center">服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新）</td></tr></tbody></table><h3 id="2-2-Response-header-响应头"><a href="#2-2-Response-header-响应头" class="headerlink" title="2.2 Response header 响应头"></a>2.2 Response header 响应头</h3><p>响应头和请求头有很多是通用的，这里只摘取几个header。</p><p><code>Content-Length</code></p><p>用来指明发送给接收方的消息主体的大小，即用十进制数字表示的八位元组的数目。</p><p><code>Content-Encoding</code></p><p>用于对特定媒体类型的数据进行压缩。当这个首部出现的时候，它的值表示消息主体进行了何种方式的内容编码转换。这个消息首部用来告知客户端应该怎样解码才能获取在 Content-Type 中标示的媒体类型内容。</p><p><code>Content-Range</code></p><p>显示的是一个数据片段在整个文件中的位置。</p><p><code>ETag</code></p><p>HTTP响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web服务器不需要发送完整的响应。而如果内容发生了变化，使用ETag有助于防止资源的同时更新相互覆盖（“空中碰撞”）。如果给定URL中的资源更改，则一定要生成新的Etag值。 因此Etags类似于指纹，也可能被某些服务器用于跟踪。 比较etags能快速确定此资源是否变化，但也可能被跟踪服务器永久存留。</p><p><code>Expires</code></p><p>指定了一个日期/时间， 在这个日期/时间之后，HTTP响应被认为是过时的；无效的日期，比如 0, 代表着一个过去的事件，即该资源已经过期了。如果还有一个 设置了 “max-age” 或者 “s-max-age” 指令的Cache-Control响应头，那么  Expires 头就会被忽略。</p><p><code>Last-Modified</code></p><p>是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。 它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。由于精确度比  ETag 要低，所以这是一个备用机制。包含有  If-Modified-Since 或 If-Unmodified-Since 首部的条件请求会使用这个字段。</p><p><code>...</code></p><h3 id="2-3-Response-body-响应体"><a href="#2-3-Response-body-响应体" class="headerlink" title="2.3 Response body 响应体"></a>2.3 Response body 响应体</h3><p>响应request请求的正文数据。</p><p>##备注</p><p><a href="https://github.com/sun6boys/Documents/blob/master/3.Http:Https%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3.md" target="_blank" rel="noopener">源文件地址</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">MDN&gt;web docs&gt;http</a></p><p><a href="http://www.daqianduan.com/4280.html" target="_blank" rel="noopener">HTTP状态码详解</a></p><p><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">HTTP权威指南</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTTP(HyperText Transfer Protocol)是一套计算机通过网络进行通信的规则。计算机专家设计出HTTP，使HTTP客户（如Web浏览器）能够从HTTP服务器(Web服务器)请求信息和服务。HTTP遵循请求(Request)/应答(Response)模
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TCP协议小叙</title>
    <link href="http://charonchu.club/2017/12/31/TCP%E5%8D%8F%E8%AE%AE%E5%B0%8F%E5%8F%99/"/>
    <id>http://charonchu.club/2017/12/31/TCP协议小叙/</id>
    <published>2017-12-30T16:50:34.000Z</published>
    <updated>2017-12-30T16:51:09.016Z</updated>
    
    <content type="html"><![CDATA[<p>目前大多数app和服务器通信的时候才有的HTTP应用层协议，而HTTP又是TCP协议实现的，所以TCP协议的重要性不言而喻。TCP是一个传输层协议位于IP协议网络层之上。从很多书籍和资料上解释TCP是可靠的传输层协议。结合下面的内容就会得到分析为什么TCP协议是可靠的传输层协议。</p><h3 id="1-TCP-Header"><a href="#1-TCP-Header" class="headerlink" title="1.TCP Header"></a>1.TCP Header</h3><p>一个TCP包由header和payload组成，payload就是待传输的数据，header信息中包含了一些对payload的描述以及一些TCP传输控制策略等，如下图。</p><p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/lpnueg4/EntryImages/20091120/TCP+bit%E5%89%AF%E6%9C%AC.png" alt="icon"></p><ul><li><strong>Source Port</strong> <code>源端口号</code>标识发送主机发起传送的应用程序。端口号在IP总结一文中作了解释，所以当时为什么说端口号应属于传输层当中的内容。</li><li><strong>Destonation Port</strong> <code>目标端口号</code> 标识目标主机接收数据的应用程序。</li><li><strong>Sequence Number</strong> <code>序列号</code> 标识该TCP包中payload第一个字节的编号，发送方必填。</li><li><strong>Acknowledgment Number</strong> <code>确认号</code> 接收方每次接收到发送方传来的数据包需要告诉发送方我已经收到了该数据（TCP可靠性体现之一，当然也并不是每个包都会被回复，下文会具体叙述），<code>确认号</code> = <code>序号和</code> + payload字节数 + 1,代表期待对方下次可以从序号号为<strong>Acknowledgment Number</strong>开始发送。意思是（Acknowledgment Number - 1）和它之前的数据已经成功收到，不需要重发那些。</li><li><strong>Data Offset</strong> 4位，也就是头部长度，指出TCP负载（数据）的开始位置。以4字节为单位，如”0101”表示20字节位置的数据为负载开始，也就是头部长度为20字节。</li><li><p><strong>Control Falg</strong> <code>控制标记</code></p><ul><li><strong>URG</strong> 如果数值为1，表示这是一个携有紧急资料的封包</li><li><strong>ACK</strong> 如果数值为1，表示该包需要回复，正常情况都是1</li><li><strong>PSH</strong> 如果为1，通知接收方立即将数据包交给应用层，而不是等缓冲区满了再交付应用层</li><li><strong>SYN</strong> 如果为1 表示双方进行同步沟通</li><li><strong>FIN</strong> 如果未1 表示任意一方已经没有数据传输了，请求终止链接。</li></ul></li><li><p><strong>Window</strong> <code>窗口</code> 接收窗口大小。用来进行流量控制，单位字节数。发送方有发送窗口，接收方有接收窗口，窗口大小代表着处理数据的能力，如果接收方发送数据的速度大于接收方处理数据的能力，那多余的数据将会丢失。</p></li><li><strong>Checksum</strong> <code>校验位</code>16位，对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。当资料要传送出去的时候发送端会计算好封包资料大小然後得出这个检验值封包一起发送当接收端收到封包之後会再对资料大小进行计算看看是否和检验值一致如果结果不相称则被视为残缺封包会要求对方重发该个封包。</li><li>…</li></ul><h3 id="2-TCP分段"><a href="#2-TCP分段" class="headerlink" title="2. TCP分段"></a>2. TCP分段</h3><p>在<a href="https://github.com/sun6boys/Documents/blob/master/1.IP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">IP协议总结</a>中说到当数据包在经过网络层，如果数据包体积超过了MTU，会把数据包分片传输。IP包在复杂的网络传输当中，可能会发生各种意外情况，比如丢包等等。TCP既然被称为可靠的协议，显然要改变这个状况。</p><p>可靠性最大的体现在发送方给接收方的数据都能够接收到，如果某一个数据没有接收到，发送方需要重新给接收方再次发送。</p><p>所以TCP的header当中<strong>Sequence Number</strong>和<strong>Acknowledgment Number</strong>就是为了实现确认和重发功能，具体见上文。</p><p><strong>举例：</strong></p><ul><li><p>发送方 需要发送1、2、3、4…、99、100共100个数字给接收方，TCP把这100个数字打包，在TCP header中记录<strong>Sequence Number</strong>，IP层接收到TCP层过来的数据，加上IP header超过了MTU大小，于是把数据包分片，第一片数据是1-50个数字，第二片是51 -100个数字，分别发送出去。</p></li><li><p>接收方收到第一个包，经过层层拆包，至TCP层，接收方根据<strong>Sequence Number</strong>回复一个<strong>Acknowledgment Number</strong>给接收方，接收方收到回复包，看到<strong>Acknowledgment Number</strong>会认为接收方已经收到完整数据了。</p></li><li><p>在这个过程当中发送方认为接收方已经收到了数据，而接收方可能只接收到了1-50的数据，51-100并没有接收到。</p></li></ul><p>TCP为了避免这样的情况发生，他需要接管数据分段，避免被IP分片。</p><p>IP数据不会发生分片前提是： IP header + IP 实际传输的数据 &lt;= MTU。</p><p>因为TCP也会封装header，他要保证单个数据包至IP层不会被分片，公式是：TCP header + TCP payload + IP header &lt;= MTU.</p><p>暂且认为TCP header 和 IP header大小固定不变，在<a href="https://github.com/sun6boys/Documents/blob/master/1.IP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">IP协议总结</a>提到过MTU，MTU大小会因为数据传输过程中物理介质不一样，以及运营商流量计费采用了比如PPPoE等协议，会给数据包二次封装等原因造成了MTU的大小不一致。</p><p>既然如此，发送方和接收方就要在正式数据传输前，约定好TCP payload的最大体积以保证不会让IP分片，这就是<strong>MSS</strong></p><p>由此可得出IP分片和TCP分段的区别：</p><ul><li>IP分片产生的原因是网络层的MTU；TCP分段产生原因是MSS，产生MSS原因其实也是MTU；</li><li>IP分片由网络层完成，也在网络层进行重组；TCP分段是在传输层完成，并在传输层进行重组；</li></ul><p>故采用TCP协议进行数据传输，是不会造成IP分片的。若数据过大，只会在传输层进行数据分段，到了IP层就不用分片。而我们常提到的IP分片是由于比如UDP传输协议造成的，因为UDP传输协议并未限定传输数据报的大小。</p><h3 id="3-流量控制（Data-Flow-Control）"><a href="#3-流量控制（Data-Flow-Control）" class="headerlink" title="3.流量控制（Data Flow Control）"></a>3.流量控制（Data Flow Control）</h3><p>TCP的传输要保证数据能够准确到达目的地，如果不能，需要能检测出来并且重新发送数据。每一台设备都有自己的承载能力，如果发送方发送数据的速度超过了接收方处理数据的速度，那超过的那部分就会被丢弃，发送方一定时间内检测不到接收方回复的ACK，就会重新发送被丢弃的那些数据。为了提高效率，避免发送方发送速度太快，导致的重发，TCP引入了滑动窗口机制。</p><h4 id="3-1-滑动窗口"><a href="#3-1-滑动窗口" class="headerlink" title="3.1 滑动窗口"></a>3.1 滑动窗口</h4><p>早前TCP为了保证可靠性采用的单次发生一个包，然后开启定时器，如果定时时间内收不到接收方ACK就重新发送刚才的包，等收到ACK后再发送下一个包，显然这样效率是很低的。 那如何一次可以发送多个包，并且不超过接收方处理数据的能力呢，滑动窗口可以解决类似问题。</p><p>所谓滑动窗口就是可变的窗口。</p><h4 id="3-1-发送窗口"><a href="#3-1-发送窗口" class="headerlink" title="3.1 发送窗口"></a>3.1 发送窗口</h4><p>发送窗口根据数据包状态划分大致划分四类</p><ul><li><strong>已回复</strong> 已经收到接收方ACK的数据包</li><li><strong>等待回复</strong> 已经发送出去的数据包，但是没有收到ACK</li><li><strong>尽快发送</strong> 准备发送的数据包</li><li><strong>未发送</strong> 当TCP层收到应用层数据达到MSS值就会组装一个数据包，按序排列，这部分的数据包属于已组装但是超过接收方接收能力的数据包。</li></ul><p>图一：</p><p><img src="https://github.com/sun6boys/Documents/blob/master/Resources/fasongchuankou1.png?raw=true" alt="icon"></p><p>接收方和发送方建立连接后，接收方通过TCP header中window（字节）告知发送方我现在可以处理4个数据包，滑动窗口挪至1-4编号的位置，并将这4个包立即发送。</p><p>图二：<br><img src="https://github.com/sun6boys/Documents/blob/master/Resources/fasongchuangkou3.png?raw=true" alt="icon"></p><p>接收方发送1-4数据包，如果等不到ACK需要重新发送，所以缓存下来，1-4号包状态变成等待回复。</p><p>图三：<br><img src="https://github.com/sun6boys/Documents/blob/master/Resources/fasongchuangkou2.png?raw=true" alt="icon"></p><p>接收方给第1-2个包ACK了，并告知发送方，我现在还可以处理3个数据包，随机滑动窗口挪至3-7的区域。并将5-7的包发送出去。1-2号包会在发送缓存即将满时清除。</p><p>窗口以字节为单位，此处举例暂忽略，此处也忽略了TCP拥塞控制，会在第四章节介绍。</p><h4 id="3-2-接收窗口"><a href="#3-2-接收窗口" class="headerlink" title="3.2 接收窗口"></a>3.2 接收窗口</h4><p>接收端也有一个接收窗口，有3个分类</p><ul><li><strong>接收并且已经回复，但是还没被应用层接收</strong></li><li><strong>已经接收，但是还没有ACK的</strong> 这部分数据可能是由于前面有一个包没有收到，所以不可以ACK，或者在等待后续的数据包，对一组数据一起ACK。</li><li><strong>空位</strong> 还没有被接收的数据</li></ul><h4 id="3-3-ACK"><a href="#3-3-ACK" class="headerlink" title="3.3 ACK"></a>3.3 ACK</h4><h5 id="SACK-选择性确认"><a href="#SACK-选择性确认" class="headerlink" title="SACK 选择性确认"></a>SACK 选择性确认</h5><p>TCP并不是对每个包都会回复ACK，可能对2个及以上的包发送一个ACK。比如发送方发送1、2、3个数据包，接收方收到了2、3的包，接收方期望收到1号包，此时接收方会把2号和3号包放在缓存当中，等待接收1号包，如果1号包一直收不到那2号和3号包也会被丢弃，如果接收到1号包，那会对这3个包进行一次确认。</p><p>上面流程中间因为接收方没收到1号包，但是收到2号3号包，所以接收方要告诉发送方我期望收到1号包，发送方把1号包及后续的包（2号3号）发送给接收方，这样原先已经正确传输的包就重复发送了，如此便降低了TCP性能。为了改善这种情况发展了SACK(Selective Acknowledgment, 选择性确认)。</p><p>SACK信息是通过TCP头的选项部分提供的，信息分两种，一种标识是否支持SACK，是在TCP握手时发送；另一种是具体的SACK信息。 </p><ul><li><strong>SACK 允许选项</strong> 在TCP握手的包中，控制标识SYN 为1的数据包header当中的option中标识各自是否支持SACK 类型为4.</li><li><strong>SACK 选项</strong> 在option中类型为5 告诉发送方接收到并缓存的数据块，由此发送方会检查哪个数据包丢失。</li></ul><p>如果上述场景中双方都支持SACK，那接收方就会告诉发送方我已经缓存了2，3号包，那发送方就只会重新发送1号包，接收方收到1号包会给1-3号包一次确认。</p><h3 id="4-拥塞控制"><a href="#4-拥塞控制" class="headerlink" title="4.拥塞控制"></a>4.拥塞控制</h3><p>网络上数据传输会经过很多物理设备（路由器，光纤），这些设备都有最大负载能力，一旦通过的数据超过了设备的处理能力，便会抛弃这些数据。这也被称作为网络拥塞。<br>出现资源拥塞的条件 是对资源需求综合 &gt; 可用资源，比如50M带宽，同一时间需要通过数据量大于50M就会出现拥塞。 </p><h4 id="4-1-慢启动-amp-拥塞避免"><a href="#4-1-慢启动-amp-拥塞避免" class="headerlink" title="4.1 慢启动&amp;拥塞避免"></a>4.1 慢启动&amp;拥塞避免</h4><p>每当发送方和接收方建立连接后，发送方不知道当前网络状况，会先缓慢的发送数据包，单次逐渐增加发送数据包的数量，直到发现丢包，再降低发送速率，依次增加速率。</p><p>发送方维持<strong>拥塞窗口 cwnd</strong>，发送方控制拥塞窗口原则是：</p><ul><li>只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。</li><li>只要网络出现拥塞，拥塞窗口就减小一些，以减小注入到网络中的分组数。</li></ul><p>慢启动&amp;拥塞避免过程图：</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1514652703610&amp;di=1426e92f74fbb9b0715834c4bf50580a&amp;imgtype=0&amp;src=http%3A%2F%2Fimages2015.cnblogs.com%2Fblog%2F833931%2F201611%2F833931-20161122000021596-1751581103.jpg" alt="icon"></p><p>慢启动&amp;拥塞避免过程介绍：</p><ol><li>如图发送方第五轮依次发送1个、2个、4个、8个、16个数据包。</li><li>第四轮发送数据包达到了<strong>慢启动门限初始值（默认16）</strong>进入拥塞避免阶段，之后依次多增加一个包，而不是像前几轮指数增加。</li><li>第12轮发送24个包后，发现有丢包现象，设置新的<strong>慢启动门限</strong>为12，（发现丢包时单次发送包的数量除以2即24/2）</li><li>第13轮重新开始慢启动流程，指数增加窗口至12.</li><li>17轮达到新的<strong>慢启动门限</strong>再次进入拥塞避免 开始依次增加一个包。</li><li>…</li></ol><p><strong>拥塞避免</strong>并非完全能够避免了拥塞。利用以上的措施要完全避免拥塞是不可能的。<strong>拥塞避免</strong>是说在拥塞避免阶段把拥塞窗口控制为按线性增长，使得网络不容易出现拥塞。</p><h4 id="4-2-快重传"><a href="#4-2-快重传" class="headerlink" title="4.2 快重传"></a>4.2 快重传</h4><p>在<strong>拥塞避免算法</strong>后提出来的拥塞控制算法。</p><p>举例：A(发送方)—-B（接收方）</p><ol><li>A发送N个号包至B</li><li>B收到1号包回复ACK(要求发送2)</li><li>B收到2号包回复ACK(要求发送3)</li><li>B收到4号包回复ACK(要求发送3)</li><li>B收到5号包回复ACK(要求发送3)</li><li>B收到6号包回复ACK(要求发送3)</li><li>…</li></ol><p>第3步中是正确的ACK，第4步中A又收到了同样的ACK，此时A应该会怀疑3号包丢了，但是也有可能是乱序造成的，所以A继续观望（如果双方支持SACK，那此时A是知道B收到了4号包）。第五步中A又同样的收到了ACK，A继续观望，可能在后面一段时间B就会收到3号包了，第6步中A又收到同样的ACK，此时A会认为丢包概率很大立即启动快重传，重新发送3号包。</p><p>快重传中冗余ACK（不包括第一个正常的）数量设置为3个启动快重传，可能因为设计者认为包乱序的概率不算低，2次冗余ACK意味着丢包概率50%乱序概率50%，而3次冗余ACK丢包的概率就大于50%了，所以立即启动重传。</p><h4 id="4-2-快恢复"><a href="#4-2-快恢复" class="headerlink" title="4.2 快恢复"></a>4.2 快恢复</h4><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2039823993,149183578&amp;fm=15&amp;gp=0.jpg" alt="icon"></p><p>发送方收到3个冗余ACK，判断丢可能包了，启动快重传，拥塞窗口并不会重新进入慢开始，而是进入快恢复，如上图。为什么直接进入快恢复我猜测既然发送方收到3个冗余ACK说明网络环境尚可。</p><blockquote><p>上文流量控制中说到发送方发送窗口大小会因接收方接收窗口影响，显然这一章介绍得出发送窗口也由拥塞窗口决定，综上所述得出 发送窗口 = MIN（接收方窗口，发送方拥塞窗口）</p></blockquote><hr><p>由本文可见MSS和ACK才是TCP称为可靠的主要原因，拥塞控制和流量控制只是为了保障可靠性提高效率的策略。</p><p>TCP建立连接的三次握手和断开连接的四次握手这里没有介绍。TCP之所以也被称为面向连接，因为接收方和发送方一旦建立连接需要专门为对方开辟资源处理对方的数据，直至断开连接。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">TCP/IP详解</a></p><p><a href="http://blog.csdn.net/wdscq1234/article/details/52444277" target="_blank" rel="noopener">TCP/IP详解：滑动窗口</a></p><p>stackoverflow及知乎等</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>下面是github源文件地址，如果发现文字阐述有误或者理解错误的地方，您可以提Issues或Pull Request,谢谢您的阅读。<br><a href="https://github.com/sun6boys/Documents/blob/master/2.TCP:UDP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">源文件地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前大多数app和服务器通信的时候才有的HTTP应用层协议，而HTTP又是TCP协议实现的，所以TCP协议的重要性不言而喻。TCP是一个传输层协议位于IP协议网络层之上。从很多书籍和资料上解释TCP是可靠的传输层协议。结合下面的内容就会得到分析为什么TCP协议是可靠的传输层
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IP协议小叙</title>
    <link href="http://charonchu.club/2017/12/31/IP%E5%8D%8F%E8%AE%AE%E5%B0%8F%E5%8F%99/"/>
    <id>http://charonchu.club/2017/12/31/IP协议小叙/</id>
    <published>2017-12-30T16:47:15.000Z</published>
    <updated>2017-12-30T16:48:26.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP协议总结"><a href="#IP协议总结" class="headerlink" title="IP协议总结"></a>IP协议总结</h1><h2 id="1、什么是IP协议"><a href="#1、什么是IP协议" class="headerlink" title="1、什么是IP协议"></a>1、什么是IP协议</h2><p>Internet Protocol应用于OSI参考模型中网络层，主要应用于在相互连接的网络之间传递IP数据包。</p><h2 id="2、基础概念"><a href="#2、基础概念" class="headerlink" title="2、基础概念"></a>2、基础概念</h2><h3 id="2-1-IP地址"><a href="#2-1-IP地址" class="headerlink" title="2.1 IP地址"></a>2.1 IP地址</h3><p>接入互联网的每一个主机（或路由器）的每一个接口会分配一个在全世界范围的唯一的32位二进制标示符（IPV4）<strong>IPV6是128位，下面叙述只针对IPV4</strong></p><p>例如：<code>11010010010010011000110000000010</code><br>为了方便理解和记忆把地址分成4段，每段是8位，中间以小数点隔开。</p><p>变成这样：<code>11010010.01001001.10001100.00000010</code><br>显然这样也不太容易记住，于是将每段中的八位二进制转成十进制</p><p>最终是这样：<code>210.73.140.2</code></p><h4 id="2-1-1-网络号-主机号"><a href="#2-1-1-网络号-主机号" class="headerlink" title="2.1.1 网络号/主机号"></a>2.1.1 网络号/主机号</h4><p>为了方便IP地址的管理以及解决IP地址分配捉襟见肘的问题，每个IP地址分割成<strong>网络号</strong>和<strong>主机号</strong>。</p><ul><li><strong>网络号</strong>表示主机（或路由器）所以链接的网络，一个网络号在整个因特网范围内是唯一的。</li><li><strong>主机号</strong>表示该网络段的某一台主机或者路由器编号，在该网络段内它也是唯一的。</li></ul><p>以32位二进制Ip地址为例<code>11010010010010011000110000000010</code></p><p>如果前8位是网络号，那后面剩下的24位为主机号。又或者前24位是网络号那后面8位是主机号。一个IP地址除去前面的网络号，后面剩下的都是主机号。</p><p>不同的网段的网络号不一样，不同的IP地址前面多少位是网络号也不一定是一样的。</p><p>那如何知道一个IP地址的网络号是多少（或者说前多少位是网络号），这里就要涉及到子网掩码。</p><h4 id="2-1-2-子网掩码"><a href="#2-1-2-子网掩码" class="headerlink" title="2.1.2 子网掩码"></a>2.1.2 子网掩码</h4><p>经常配置网络子网掩码的同学，一定对<strong>255.255.255.0</strong>特别熟悉，这里就以<strong>255.255.255.0</strong>为例，将它转成二进制 <code>11111111 11111111 11111111 00000000</code>该子网掩码经转换后就是24个1，加8个0，代表着IP地址前24位代表网络号后8位代表主机号。</p><p>有些IP地址会用（<em>nix表示法），比如<code>192.9.200.13/24</code>代表 <strong>192.9.200.13</strong>前24位是网络号 和子网掩码<em>*255.255.255.0</em></em>意思一致。</p><h6 id="如何计算网络地址？这里用到与运算"><a href="#如何计算网络地址？这里用到与运算" class="headerlink" title="如何计算网络地址？这里用到与运算"></a>如何计算网络地址？这里用到与运算</h6><p>例如IP地址为：<strong>202.99.160.50</strong> 子网掩码是<strong>255.255.255.0</strong>，步骤如下</p><ol><li><p>将<strong>202.99.160.50</strong>转换成二进制  11001010 01100011 10100000 00110010</p></li><li><p>将<strong>255.255.255.0</strong> 转换成二进制  11111111 11111111 11111111 11111111</p></li><li><p>将二者与运算</p><p>11001010 01100011 10100000 00110010</p><p>11111111 11111111 11111111 00000000</p><p>———–与运算———————————-</p><p>11001010 01100011 10100000 00000000   转换成十进制202.99.160.0，这就是网络号</p></li></ol><h3 id="2-2-DNS"><a href="#2-2-DNS" class="headerlink" title="2.2 DNS"></a>2.2 DNS</h3><p>正常情况下我们访问网络上某一台服务器只需要知道它的IP地址就能连接上，但是即使是转换成十进制的二进制地址也是难以让人记住的，所以我们访问某个网站时更多的是在浏览器地址输入域名，但是在网络层只认IP不认域名，所以DNS服务器帮助我们把域名解析成IP地址。那DNS解析流程是怎么样的呢？这里会涉及到几个节点。</p><ul><li><strong>主机</strong>，某一个接入互联网的PC电脑</li><li><strong>本地DNS服务器</strong></li><li><strong>根域名服务器</strong></li><li><strong>顶级域名服务器（比如.com域名服务器）</strong></li><li><strong>具体域名服务器 (比如jd.com)</strong><code>这都是自己想的名词，有点怪</code></li></ul><p>例:用户在主机浏览器输入<code>www.jd.com</code>DNS解析流程如下</p><ol><li>主机先查询自己的hosts文件及本地DNS缓存，查询是否有和<code>www.jd.com</code>匹配的域名,查询到直接连接服务器，查询不到走2</li><li>客户端联系<strong>本地DNS服务器</strong>查询域名，如果没有<strong>本地DNS服务器</strong>会请求<strong>根域名服务器</strong></li><li><strong>根域名服务器</strong>如果也查询不到相应的配置，会返回<code>.com的顶级域名服务器地址</code>给<strong>本地DNS服务器</strong></li><li><strong>本地DNS服务器</strong>请求<strong>.com域名服务器</strong>查询<code>www.jd.com</code>的IP地址，如果<strong>.com域名服务器</strong>也查询不到会返回<strong>jd.com的域名服务器</strong>的地址</li><li><strong>本地DNS服务器</strong>请求<strong>jd.com的域名服务器</strong>，<strong>jd.com的域名服务器</strong>将IP地址返回给<strong>本地DNS服务器</strong></li><li><strong>本地DNS服务器</strong>将解析到的IP地址返回给<strong>主机</strong>，<strong>主机</strong>缓存该IP地址，下次再次连接<code>jd.com</code>会直接从缓存中获取到相应的IP地址</li></ol><h3 id="2-3-端口号"><a href="#2-3-端口号" class="headerlink" title="2.3 端口号"></a>2.3 端口号</h3><p>IP地址是一台主机在互联网中的标示，端口号是这台主机的唯一的一个程序的标识。所以如果需要和某台计算机建立连接的话，只需要知道IP地址或域名即可，但是如果想和该台计算机上的某个程序交换数据的话，还必须知道该程序使用的端口号。</p><p>端口号不属于网络层（IP协议）中的内容，它属于传输层中的内容，每个IP包在经过传输层打包的时候会在TCP/UDP header中添加源端口号和目标端口号。</p><h3 id="2-4-MAC地址"><a href="#2-4-MAC地址" class="headerlink" title="2.4 MAC地址"></a>2.4 MAC地址</h3><p>数据包经网络层处理完毕至数据链路层，因为数据链路层不认IP地址，所以需要用到MAC地址。</p><p>MAC地址是接入网络中主机或者路由器的标识，由网卡生成厂家在生产的时候就植入到芯片当中，每一个MAC地址都是唯一的。</p><p>数据帧在由路由器中传输的时候，会修改frame当中源mac地址为自己的mac地址，目的地mac地址为下一跳设备的mac地址。</p><p>所以数据包在每经过一个路由器的时候源mac地址和目标mac地址都会改变，记得我们团队当时做接口防刷，有人提出通过记录请求的MAC地址来达到防刷目的，事实上这样是不可行的，除非在HTTP header中添加源主机的MAC地址。</p><h3 id="2-5-ARP协议"><a href="#2-5-ARP协议" class="headerlink" title="2.5 ARP协议"></a>2.5 ARP协议</h3><p>如果同一个网络段内2台主机传输数据就必须知道对方的MAC地址，如果是不同网段内发送请求的主机也必须知道上一网关（路由器）的mac地址。那如何知道对方的MAC地址呢？</p><p>A主机向B主机发送数据，首先A主机肯定得知道B主机的IP地址，A主机先根据B主机的IP地址计算出网络号，如果网络号和自己一样，那说明是B和自己处于同一局域网下，A主机会在局域网内发送一个ARP广播，内容大致是<strong>这个IP地址的主机MAC地址是什么</strong>，同一局域网内的主机都会收到这个广播，B主机接到该广播消息，一看这不是我的IP地址么，于是就回复该广播消息我的MAC地址是xxx，A主机收到B主机回复的消息，于是在链路层header中的源MAC地址写上自己的MAC地址，目标MAC地址写上B主机的MAC地址，这样数据就开始发送了。收到B主机的回复消息A主机会缓存B主机IP地址和它MAC地址的映射关系，下次再给B发送消息就不用再发送ARP广播了。</p><p>如果A主机算出B主机网络号和自己不是同一网段，A主机会给网关（路由器）定向发送ARP消息，问网关的MAC地址，网关回复A主机它的MAC地址，A主机在链路层header中的源MAC地址写上网关的MAC地址，然后把数据交给网关。</p><h3 id="2-6-路由表-Routing-Table"><a href="#2-6-路由表-Routing-Table" class="headerlink" title="2.6 路由表(Routing Table)"></a>2.6 路由表(Routing Table)</h3><p>互联网中2个主机通信，A主机要找到B主机，中间可能会经过好多个路由器，就像现实中从上海到北京一样，如果拿着地图，可以很方便的找到从上海到达北京的路径。路由表就是网络传输中的地图，只是它（<strong>动态路由</strong>）有时不像现实地图那样一眼就能知道全路程怎么走，它有时候只知道下一站是什么，就像单向链表一样，每个节点只知道自己下一个节点，但是最终也能找到尾节点。</p><ul><li>路由器有多个接口，因为路由器主要功能是隔离网段所以每个接口的网段肯定不一样。</li><li>默认路由器只知道直连的路由信息。</li><li>路由器必须通过某种方式获知非直连路由。</li></ul><p>那如何知道路由器如何知道非直连路由呢？</p><ol><li><p><strong>静态路由</strong>由管理员手动配置路由表，比如从网段1 到网段2 需要经过哪几个路由器的哪几个接口都需要手动配置。</p><p>   优点：</p><ul><li>占用路由器资源小</li><li>可以严格控制路由转发</li><li>支持广泛</li></ul><p>缺点：</p><ul><li>出现网络拓扑变动时还需要管理员手动去更新</li><li>当网络很大时配置维护比较复杂</li></ul><p>所以静态路由只适合一些小型网络，或者需要严格策略控制的网络。</p><p>路由表只匹配网络段，不匹配主机段。如果现在管理员在路由表中配置了3条路由分别是：</p><ul><li>192.168.1.128/30</li><li>192.168.1.0/24</li><li>192.168.0.0/16</li></ul><p>现在有一个数据包是发到<code>192.168.1.129</code>,现在分别与这3条路由去匹配，显然第一条路由信息只匹配前30位能够匹配上，第二条路由匹配前24位也能匹配上，同理第3条也能匹配上，但是路由器会选择第一条。 因为路由器会选择匹配位数最高的那一条路由。</p><p>路由器匹配到一个路由信息，必须找到一个出接口才能进行转发，如果没有匹配到路由会丢弃数据包，并向源返回一个ICMP报错信息。</p></li><li><p><strong>动态路由</strong>如果是一个大型网络，网络当中有成百上千个路由器，显然用静态配置路由的方式会很困难，这里就要采用动态路由协议。动态路由协议实际上市运行在路由器上的一个软件，相同的动态路由协议通过在不同的路由器之间交换该动态路由协议规定的数据包来交换各自的路由信息，从而达到学习路由、维护路由表、发现网络拓扑变动的目的。</p></li></ol><p> <img src="https://raw.githubusercontent.com/sun6boys/Documents/master/Resources/routingScreenshot.png" alt="icon"></p><p>  上面提到<code>默认路由器只知道直连的路由信息。</code>所以路由器A是知道我的s0/0/0接口是连接10.2.0.0网段的的，同理B也知道我的s0/0/0接口连接10.3.0.0网段的，通过动态路由协议，路由器A告诉路由器B，我还有一个fa0/0接口是连接10.1.0.0网段的，路由器B告诉路由器C我有一个接口是连接10.2.0.0网段的，并且路由器A有一个接口是连接10.1.0.0网段的，通过动态学习3个路由器都知道了相互的链接信息，并且把信息缓存在路由表中。</p><h2 id="3、分片和重组"><a href="#3、分片和重组" class="headerlink" title="3、分片和重组"></a>3、分片和重组</h2><p>说到分段重组不得不提一个很重要的概念MTU，它也是造成IP协议分段和重组的原因。</p><h3 id="3-1-MTU"><a href="#3-1-MTU" class="headerlink" title="3.1 MTU"></a>3.1 MTU</h3><p>当2台主机在网络中通信的时候，数据包会穿过各种路由器和物理媒介，不同的媒介都限制了单个数据包能通过自己的最大体积，这就是MTU<strong>最大传输单元</strong>,2台主机在传输数据前IP协议会事先确定MTU。</p><h3 id="3-2-IP分片"><a href="#3-2-IP分片" class="headerlink" title="3.2 IP分片"></a>3.2 IP分片</h3><p>如果一个数据包的体积超过了MTU传输，转发设备就会根据要求丢弃这个数据包，然后返回一个错误信息给发送者，这样会造成某些通讯上的问题。</p><h4 id="3-2-1-什么是IP分片？"><a href="#3-2-1-什么是IP分片？" class="headerlink" title="3.2.1 什么是IP分片？"></a>3.2.1 什么是IP分片？</h4><p>IP协议在传输数据包时，将数据包分为若干段（不超过MTU）大小进行传输，并在目标系统中进行重组。这个过程称为分片。</p><h4 id="3-2-2-分片原理"><a href="#3-2-2-分片原理" class="headerlink" title="3.2.2 分片原理"></a>3.2.2 分片原理</h4><p>这里介绍下IP报头的主要内容，如图所示<br><img src="http://img.blog.csdn.net/20170301092349308" alt="icon"></p><ul><li><strong>版本</strong> IP协议的版本，IPV4 或者IPV6</li><li><strong>首部长度</strong> IP报头长度最小20字节 最大60字节，所以可变长度是40字节</li><li><strong>总长度</strong> IP报头长度与数据部分长度之和（不超过MTU）</li><li><strong>标识</strong> 目标主机可能会同时接收好几台主机给他发来的数据，所以需要给某次传输的数据标示，避免目标主机将2个不相关的数据包进行重组</li><li><strong>位偏移</strong> 该分片数据包相对于完整数据包首位的偏移位，避免目标主机重组时乱序</li><li><strong>源地址</strong> 发送主机IP地址</li><li><strong>目的地址</strong> 目标主机IP地址</li><li>…..</li></ul><p>IP分片和完整IP报文差不多拥有相同的IP头，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位识别号唯一记录了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而13位片偏移则记录了某IP片相对整个包的位置；而这表中间的<strong>标志</strong>则标志着该分片后面是否还有新的分片。接受方就可以利用这些信息对IP数据进行重新组织。</p><h3 id="3-3-重组"><a href="#3-3-重组" class="headerlink" title="3.3 重组"></a>3.3 重组</h3><p>正如上面所说，<strong>标识</strong> 是分片前的完整数据包的ID，<strong>位偏移</strong>是分片的数据包基于分片前数据包的偏移位。<br>打比方 <strong>标识</strong>代表的班级名称，<strong>位偏移</strong>代表班级某学生的编号，如果校长现在要将学生按照班级排列，并且同一个班级的学生要按照编号排位，那他只要知道每个学生是哪个班级以及编号是多少即可。</p><hr><p>TCP/IP 是一个庞大的系统网络工程，几年前读过《TCP/IP协议族》这本书，很多知识都一知半懂，现在回过头写这些总结很多概念都已经忘记了。这篇文章介绍的部分知识虽然只是IP协议相关知识的九牛一毛，但是如果能给您带来哪怕一点点帮助，我都会很开心的。</p><p>这篇文章的介绍很多都是靠我自己的理解来阐述出来，可能有一些理解有误的地方，如果您发现了错误的地方，下面是github源文件地址，您可以提Issues或Pull Request,谢谢您的阅读。<br><a href="https://github.com/sun6boys/Documents/blob/master/1.IP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">源文件地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IP协议总结&quot;&gt;&lt;a href=&quot;#IP协议总结&quot; class=&quot;headerlink&quot; title=&quot;IP协议总结&quot;&gt;&lt;/a&gt;IP协议总结&lt;/h1&gt;&lt;h2 id=&quot;1、什么是IP协议&quot;&gt;&lt;a href=&quot;#1、什么是IP协议&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>firstPage</title>
    <link href="http://charonchu.club/2017/10/09/firstPage/"/>
    <id>http://charonchu.club/2017/10/09/firstPage/</id>
    <published>2017-10-09T13:49:56.000Z</published>
    <updated>2017-10-09T13:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is my first page</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This is my first page&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://charonchu.club/2017/10/09/hello-world/"/>
    <id>http://charonchu.club/2017/10/09/hello-world/</id>
    <published>2017-10-09T13:03:51.000Z</published>
    <updated>2017-10-09T13:03:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
